# Interactive Evolution Strategy (ES) Pathfinder

This project demonstrates a real-time pathfinding visualizer that uses an Evolution Strategy (ES) algorithm to find the shortest path between a source and a destination while avoiding obstacles. The application is built with a Python backend (Flask-SocketIO) and a JavaScript frontend.

## How It Works

The core of the project is a `(1+1)-ES` (one parent, one offspring, elitist selection) algorithm implemented in Python.

1.  **Initialization**: A straight-line path is created between the source and destination, populated with a set number of waypoints. This path is our initial "parent". Each waypoint's coordinate is a parameter for the ES.

2.  **Fitness Calculation**: The "fitness" of a path is calculated based on two main criteria:
    *   **Path Length**: The total Euclidean distance of all segments. The primary goal is to minimize this.
    *   **Penalties**:
        *   **Obstacle Collision**: A massive penalty is applied if any path segment gets too close to an obstacle (violating a predefined clearance distance). This makes such paths highly "unfit".
        *   **Boundary Violation**: A penalty is also applied if the path goes outside the defined environment boundaries.

3.  **Mutation**: A new "offspring" path is generated by mutating the parent path. This is done by adding a small amount of random noise to each waypoint's coordinates. The magnitude of this noise (the `sigma` value) is self-adaptive, meaning it also evolves over time to allow for both fine-tuning and larger exploratory jumps.

4.  **Selection**: The fitness of the new offspring path is compared to the parent's fitness. If the offspring is better (i.e., has a lower cost), it replaces the parent for the next generation. This is an elitist strategy known as `(1+1)-ES`.

5.  **Evolution**: This process of mutation and selection is repeated for a set number of generations. Over time, the path evolves to become shorter and to navigate around obstacles.

6.  **Real-time Visualization**: The Python backend uses Flask and SocketIO to stream the best path of each generation to the web frontend, allowing you to see the algorithm "thinking" and improving the path in real-time.

## How to Run the Project

1.  **Prerequisites**:
    *   Python 3.x
    *   `pip` (Python package installer)

2.  **Setup a Virtual Environment** (recommended):
    ```bash
    python -m venv es_env
    source es_env/bin/activate  # On Windows, use `es_env\Scripts\activate`
    ```

3.  **Install Dependencies**:
    ```bash
    pip install Flask Flask-SocketIO numpy shapely
    ```

4.  **Run the Server**:
    ```bash
    python app.py
    ```

5.  **Open the Application**:
    Open your web browser and navigate to `http://127.0.0.1:5000`.

6.  **Interact with the UI**:
    *   Use the "Map Action" dropdown to choose between setting the **Source**, **Destination**, or drawing **Obstacles**.
    *   Click on the canvas to place the source and destination points.
    *   Click and drag on the canvas to draw rectangular obstacles.
    *   Adjust the ES parameters (Waypoints, Generations, Sigma) as needed.
    *   Click "Run Evolution" to start the pathfinding process.
    *   Click "Reset Map" to clear everything.

## Files in the Project

*   `app.py`: The Flask web server that handles the connection with the browser via SocketIO. It receives the map setup from the client and orchestrates the pathfinding process.
*   `es_pathfinder.py`: Contains the core logic for the Evolution Strategy algorithm, including fitness calculation, mutation, and the main solver loop.
*   `index.html`: The single-page web application that provides the user interface. It handles user input, canvas drawing, and communication with the backend server.

## Technologies Used

*   **Backend**:
    *   Python
    *   Flask (for the web server)
    *   Flask-SocketIO (for real-time WebSocket communication)
    *   NumPy (for numerical operations)
    *   Shapely (for geometric calculations like obstacle distance)

*   **Frontend**:
    *   HTML5 (Canvas API for drawing)
    *   JavaScript (for UI logic and interactivity)
    *   Socket.IO Client (to connect to the backend)
